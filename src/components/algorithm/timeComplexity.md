## 시간 복잡도

><span style="font-size: 16px">
>알고리즘 문제를 풀때 반드시 알아둬야 하는 지식중 하나가 복잡도이론이다.
></span>

---

+	#### 문제에는 제한 시간이 있으며 제한시간 내에 오류 없이 동작하는 코드를 작성해야한다
+	#### 문제에서 주어지는 입력중 가장 오래 걸리는 형태가 들어 왔을때 제한시간 내에 답을 출력할수 있을까? 이를 가늠할때 필요한게 `시간 복잡도` 개녑이다.
+ #### 시간 복잡도는 빅-오(Big-O) 표기법으로 나타낸다.

## 빅-오(Big-O) 표기법
+ #### 입력 범위 N에 비례해서 연산 횟수가 늘어나는 정고를 나타낸다.
+ #### 예시로 반복문을 사용해야하는 문제에서 반복문을 사용하는 방법을 O(N)으로 나타낼 수 있다.
+ #### 1부터 100,000,000 까지 숫자를 더하는 문제가 있다면 $ N * (N + 1)\over 2 $ 수식을 사용하는 방법도 있다, 이 수식을 사용하는 방법은 N이 몇이건 연산횟수는 상수이므로 `O(1)`이다.
+ #### 빅-오(Big-O) 표기법 에서는 가장 큰 항만 남기고 작은 항들과 계수는 전부 생략할 수 있다.
+ #### 어떤 알고리즘은 연산 횟수가 총 $3N^2 + 10N + 700$ 이라면 시간 복잡도는 $O(N^2)$로 나타낼수 있다 이알고리즘은 N이 20배 증가하면 연산수는 약400배로 증가하게 된다.
+ #### 항상 그런건 아니지만 보통 $k$중 반복문(for)을 사용하면 시간 복잡도는 $O(N^k)$로 나타낼수 있다, 이중으로 for문을 사용하게 된다면 $O(N^2)$, 삼중으로 사용하게 된다면 $O(N^3)$이 된다.
+ #### 실제 코딩 테스트에서 작성한 알고리즘의 실제 연산 횟수를 세고 제한시간 내에 동작하는 코드인지 파악하기에는 시간이 부족하므로 대략적으로 파악하는게 일반적이다.
+ #### 예를들어 1부터 N까지 의 숫자를 더하는 문제가 있을때 N이 10,000이고 제한시간이 1초라면 O(N)으로 풀어도 O(1) 로 풀어도 통과할수 있지만 N이 200,000,000 이라면 O(N)으로는 제한시간을 초과할수 있다 이럴경우 O(1)알고리즘을 풀수 있다.$O(1)=$ $N * (N + 1)\over 2$
